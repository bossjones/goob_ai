"""
This type stub file was generated by pyright.
"""

import inspect
from dataclasses import dataclass
from typing import Any, Callable, ClassVar, Coroutine, Dict, List, Optional, TYPE_CHECKING, Tuple, Type, TypeVar, Union
from .models import Choice
from .translator import Translator, locale_str
from ..enums import AppCommandOptionType, ChannelType
from ..member import Member
from ..interactions import Interaction
from .commands import Parameter

"""
The MIT License (MIT)

Copyright (c) 2015-present Rapptz

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
"""
__all__ = ('Transformer', 'Transform', 'Range')
T = TypeVar('T')
FuncT = TypeVar('FuncT', bound=Callable[..., Any])
ChoiceT = TypeVar('ChoiceT', str, int, float, Union[str, int, float])
NoneType = ...
if TYPE_CHECKING:
    ...
@dataclass
class CommandParameter:
    name: str = ...
    description: Union[str, locale_str] = ...
    required: bool = ...
    default: Any = ...
    choices: List[Choice[Union[str, int, float]]] = ...
    type: AppCommandOptionType = ...
    channel_types: List[ChannelType] = ...
    min_value: Optional[Union[int, float]] = ...
    max_value: Optional[Union[int, float]] = ...
    autocomplete: Optional[Callable[..., Coroutine[Any, Any, Any]]] = ...
    _rename: Union[str, locale_str] = ...
    _annotation: Any = ...
    async def get_translated_payload(self, translator: Translator, data: Parameter) -> Dict[str, Any]:
        ...
    
    def to_dict(self) -> Dict[str, Any]:
        ...
    
    def is_choice_annotation(self) -> bool:
        ...
    
    async def transform(self, interaction: Interaction, value: Any, /) -> Any:
        ...
    
    @property
    def display_name(self) -> str:
        """:class:`str`: The name of the parameter as it should be displayed to the user."""
        ...
    


class Transformer:
    """The base class that allows a type annotation in an application command parameter
    to map into a :class:`~discord.AppCommandOptionType` and transform the raw value into one
    from this type.

    This class is customisable through the overriding of methods and properties in the class
    and by using it as the second type parameter of the :class:`~discord.app_commands.Transform`
    class. For example, to convert a string into a custom pair type:

    .. code-block:: python3

        class Point(typing.NamedTuple):
            x: int
            y: int

        class PointTransformer(app_commands.Transformer):
            async def transform(self, interaction: discord.Interaction, value: str) -> Point:
                (x, _, y) = value.partition(',')
                return Point(x=int(x.strip()), y=int(y.strip()))

        @app_commands.command()
        async def graph(
            interaction: discord.Interaction,
            point: app_commands.Transform[Point, PointTransformer],
        ):
            await interaction.response.send_message(str(point))

    If a class is passed instead of an instance to the second type parameter, then it is
    constructed with no arguments passed to the ``__init__`` method.

    .. versionadded:: 2.0
    """
    __discord_app_commands_transformer__: ClassVar[bool] = ...
    __discord_app_commands_is_choice__: ClassVar[bool] = ...
    def __call__(self) -> None:
        ...
    
    def __or__(self, rhs: Any) -> Any:
        ...
    
    @property
    def type(self) -> AppCommandOptionType:
        """:class:`~discord.AppCommandOptionType`: The option type associated with this transformer.

        This must be a :obj:`property`.

        Defaults to :attr:`~discord.AppCommandOptionType.string`.
        """
        ...
    
    @property
    def channel_types(self) -> List[ChannelType]:
        """List[:class:`~discord.ChannelType`]: A list of channel types that are allowed to this parameter.

        Only valid if the :meth:`type` returns :attr:`~discord.AppCommandOptionType.channel`.

        This must be a :obj:`property`.

        Defaults to an empty list.
        """
        ...
    
    @property
    def min_value(self) -> Optional[Union[int, float]]:
        """Optional[:class:`int`]: The minimum supported value for this parameter.

        Only valid if the :meth:`type` returns :attr:`~discord.AppCommandOptionType.number`
        :attr:`~discord.AppCommandOptionType.integer`, or :attr:`~discord.AppCommandOptionType.string`.

        This must be a :obj:`property`.

        Defaults to ``None``.
        """
        ...
    
    @property
    def max_value(self) -> Optional[Union[int, float]]:
        """Optional[:class:`int`]: The maximum supported value for this parameter.

        Only valid if the :meth:`type` returns :attr:`~discord.AppCommandOptionType.number`
        :attr:`~discord.AppCommandOptionType.integer`, or :attr:`~discord.AppCommandOptionType.string`.

        This must be a :obj:`property`.

        Defaults to ``None``.
        """
        ...
    
    @property
    def choices(self) -> Optional[List[Choice[Union[int, float, str]]]]:
        """Optional[List[:class:`~discord.app_commands.Choice`]]: A list of up to 25 choices that are allowed to this parameter.

        Only valid if the :meth:`type` returns :attr:`~discord.AppCommandOptionType.number`
        :attr:`~discord.AppCommandOptionType.integer`, or :attr:`~discord.AppCommandOptionType.string`.

        This must be a :obj:`property`.

        Defaults to ``None``.
        """
        ...
    
    async def transform(self, interaction: Interaction, value: Any, /) -> Any:
        """|maybecoro|

        Transforms the converted option value into another value.

        The value passed into this transform function is the same as the
        one in the :class:`conversion table <discord.app_commands.Namespace>`.

        Parameters
        -----------
        interaction: :class:`~discord.Interaction`
            The interaction being handled.
        value: Any
            The value of the given argument after being resolved.
            See the :class:`conversion table <discord.app_commands.Namespace>`
            for how certain option types correspond to certain values.
        """
        ...
    
    async def autocomplete(self, interaction: Interaction, value: Union[int, float, str], /) -> List[Choice[Union[int, float, str]]]:
        """|coro|

        An autocomplete prompt handler to be automatically used by options using this transformer.

        .. note::

            Autocomplete is only supported for options with a :meth:`~discord.app_commands.Transformer.type`
            of :attr:`~discord.AppCommandOptionType.string`, :attr:`~discord.AppCommandOptionType.integer`,
            or :attr:`~discord.AppCommandOptionType.number`.

        Parameters
        -----------
        interaction: :class:`~discord.Interaction`
            The autocomplete interaction being handled.
        value: Union[:class:`str`, :class:`int`, :class:`float`]
            The current value entered by the user.

        Returns
        --------
        List[:class:`~discord.app_commands.Choice`]
            A list of choices to be displayed to the user, a maximum of 25.

        """
        ...
    


class IdentityTransformer(Transformer):
    def __init__(self, type: AppCommandOptionType) -> None:
        ...
    
    @property
    def type(self) -> AppCommandOptionType:
        ...
    
    async def transform(self, interaction: Interaction, value: Any, /) -> Any:
        ...
    


class RangeTransformer(IdentityTransformer):
    def __init__(self, opt_type: AppCommandOptionType, *, min: Optional[Union[int, float]] = ..., max: Optional[Union[int, float]] = ...) -> None:
        ...
    
    @property
    def min_value(self) -> Optional[Union[int, float]]:
        ...
    
    @property
    def max_value(self) -> Optional[Union[int, float]]:
        ...
    


class LiteralTransformer(IdentityTransformer):
    def __init__(self, values: Tuple[Any, ...]) -> None:
        ...
    
    @property
    def choices(self): # -> list[Choice[Any]]:
        ...
    


class ChoiceTransformer(IdentityTransformer):
    __discord_app_commands_is_choice__: ClassVar[bool] = ...
    def __init__(self, inner_type: Any) -> None:
        ...
    


class EnumValueTransformer(Transformer):
    def __init__(self, enum: Any) -> None:
        ...
    
    @property
    def type(self) -> AppCommandOptionType:
        ...
    
    @property
    def choices(self): # -> list[Choice[Any]]:
        ...
    
    async def transform(self, interaction: Interaction, value: Any, /) -> Any:
        ...
    


class EnumNameTransformer(Transformer):
    def __init__(self, enum: Any) -> None:
        ...
    
    @property
    def type(self) -> AppCommandOptionType:
        ...
    
    @property
    def choices(self): # -> list[Choice[Any]]:
        ...
    
    async def transform(self, interaction: Interaction, value: Any, /) -> Any:
        ...
    


class InlineTransformer(Transformer):
    def __init__(self, annotation: Any) -> None:
        ...
    
    @property
    def type(self) -> AppCommandOptionType:
        ...
    
    async def transform(self, interaction: Interaction, value: Any, /) -> Any:
        ...
    


if TYPE_CHECKING:
    ...
else:
    ...
class MemberTransformer(Transformer):
    @property
    def type(self) -> AppCommandOptionType:
        ...
    
    async def transform(self, interaction: Interaction, value: Any, /) -> Member:
        ...
    


class BaseChannelTransformer(Transformer):
    def __init__(self, *channel_types: Type[Any]) -> None:
        ...
    
    @property
    def type(self) -> AppCommandOptionType:
        ...
    
    @property
    def channel_types(self) -> List[ChannelType]:
        ...
    
    async def transform(self, interaction: Interaction, value: Any, /): # -> Any:
        ...
    


class RawChannelTransformer(BaseChannelTransformer):
    async def transform(self, interaction: Interaction, value: Any, /): # -> Any:
        ...
    


class UnionChannelTransformer(BaseChannelTransformer):
    async def transform(self, interaction: Interaction, value: Any, /): # -> Any:
        ...
    


CHANNEL_TO_TYPES: Dict[Any, List[ChannelType]] = ...
BUILT_IN_TRANSFORMERS: Dict[Any, Transformer] = ...
ALLOWED_DEFAULTS: Dict[AppCommandOptionType, Tuple[Type[Any], ...]] = ...
def get_supported_annotation(annotation: Any, *, _none: type = ..., _mapping: Dict[Any, Transformer] = ...) -> Tuple[Any, Any, bool]:
    """Returns an appropriate, yet supported, annotation along with an optional default value.

    The third boolean element of the tuple indicates if default values should be validated.

    This differs from the built in mapping by supporting a few more things.
    Likewise, this returns a "transformed" annotation that is ready to use with CommandParameter.transform.
    """
    ...

def annotation_to_parameter(annotation: Any, parameter: inspect.Parameter) -> CommandParameter:
    """Returns the appropriate :class:`CommandParameter` for the given annotation.

    The resulting ``_annotation`` attribute might not match the one given here and might
    be transformed in order to be easier to call from the ``transform`` asynchronous function
    of a command parameter.
    """
    ...

