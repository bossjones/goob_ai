"""
This type stub file was generated by pyright.
"""

from typing import Any, Callable, Coroutine, Dict, Generator, Generic, List, Literal, Optional, Sequence, TYPE_CHECKING, Union, overload
from .models import AppCommand
from .commands import Command, CommandCallback, ContextMenu, ContextMenuCallback, Group, P, T
from .errors import AppCommandError
from .translator import Translator, locale_str
from ..enums import AppCommandType
from .._types import ClientT
from ..interactions import Interaction
from ..abc import Snowflake

"""
The MIT License (MIT)

Copyright (c) 2015-present Rapptz

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, sublicense,
and/or sell copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
"""
if TYPE_CHECKING:
    ErrorFunc = Callable[[Interaction, AppCommandError], Coroutine[Any, Any, Any],]
__all__ = ('CommandTree', )
_log = ...
class CommandTree(Generic[ClientT]):
    """Represents a container that holds application command information.

    Parameters
    -----------
    client: :class:`~discord.Client`
        The client instance to get application command information from.
    fallback_to_global: :class:`bool`
        If a guild-specific command is not found when invoked, then try falling back into
        a global command in the tree. For example, if the tree locally has a ``/ping`` command
        under the global namespace but the guild has a guild-specific ``/ping``, instead of failing
        to find the guild-specific ``/ping`` command it will fall back to the global ``/ping`` command.
        This has the potential to raise more :exc:`~discord.app_commands.CommandSignatureMismatch` errors
        than usual. Defaults to ``True``.
    """
    def __init__(self, client: ClientT, *, fallback_to_global: bool = ...) -> None:
        ...
    
    async def fetch_command(self, command_id: int, /, *, guild: Optional[Snowflake] = ...) -> AppCommand:
        """|coro|

        Fetches an application command from the application.

        Parameters
        -----------
        command_id: :class:`int`
            The ID of the command to fetch.
        guild: Optional[:class:`~discord.abc.Snowflake`]
            The guild to fetch the command from. If not passed then the global command
            is fetched instead.

        Raises
        -------
        HTTPException
            Fetching the command failed.
        MissingApplicationID
            The application ID could not be found.
        NotFound
            The application command was not found.
            This could also be because the command is a guild command
            and the guild was not specified and vice versa.

        Returns
        --------
        :class:`~discord.app_commands.AppCommand`
            The application command.
        """
        ...
    
    async def fetch_commands(self, *, guild: Optional[Snowflake] = ...) -> List[AppCommand]:
        """|coro|

        Fetches the application's current commands.

        If no guild is passed then global commands are fetched, otherwise
        the guild's commands are fetched instead.

        .. note::

            This includes context menu commands.

        Parameters
        -----------
        guild: Optional[:class:`~discord.abc.Snowflake`]
            The guild to fetch the commands from. If not passed then global commands
            are fetched instead.

        Raises
        -------
        HTTPException
            Fetching the commands failed.
        MissingApplicationID
            The application ID could not be found.

        Returns
        --------
        List[:class:`~discord.app_commands.AppCommand`]
            The application's commands.
        """
        ...
    
    def copy_global_to(self, *, guild: Snowflake) -> None:
        """Copies all global commands to the specified guild.

        This method is mainly available for development purposes, as it allows you
        to copy your global commands over to a testing guild easily.

        Note that this method will *override* pre-existing guild commands that would conflict.

        Parameters
        -----------
        guild: :class:`~discord.abc.Snowflake`
            The guild to copy the commands to.

        Raises
        --------
        CommandLimitReached
            The maximum number of commands was reached for that guild.
            This is currently 100 for slash commands and 5 for context menu commands.
        """
        ...
    
    def add_command(self, command: Union[Command[Any, ..., Any], ContextMenu, Group], /, *, guild: Optional[Snowflake] = ..., guilds: Sequence[Snowflake] = ..., override: bool = ...) -> None:
        """Adds an application command to the tree.

        This only adds the command locally -- in order to sync the commands
        and enable them in the client, :meth:`sync` must be called.

        The root parent of the command is added regardless of the type passed.

        Parameters
        -----------
        command: Union[:class:`Command`, :class:`Group`]
            The application command or group to add.
        guild: Optional[:class:`~discord.abc.Snowflake`]
            The guild to add the command to. If not given or ``None`` then it
            becomes a global command instead.
        guilds: List[:class:`~discord.abc.Snowflake`]
            The list of guilds to add the command to. This cannot be mixed
            with the ``guild`` parameter. If no guilds are given at all
            then it becomes a global command instead.
        override: :class:`bool`
            Whether to override a command with the same name. If ``False``
            an exception is raised. Default is ``False``.

        Raises
        --------
        ~discord.app_commands.CommandAlreadyRegistered
            The command was already registered and no override was specified.
        TypeError
            The application command passed is not a valid application command.
            Or, ``guild`` and ``guilds`` were both given.
        CommandLimitReached
            The maximum number of commands was reached globally or for that guild.
            This is currently 100 for slash commands and 5 for context menu commands.
        """
        ...
    
    @overload
    def remove_command(self, command: str, /, *, guild: Optional[Snowflake] = ..., type: Literal[AppCommandType.message, AppCommandType.user]) -> Optional[ContextMenu]:
        ...
    
    @overload
    def remove_command(self, command: str, /, *, guild: Optional[Snowflake] = ..., type: Literal[AppCommandType.chat_input] = ...) -> Optional[Union[Command[Any, ..., Any], Group]]:
        ...
    
    @overload
    def remove_command(self, command: str, /, *, guild: Optional[Snowflake] = ..., type: AppCommandType) -> Optional[Union[Command[Any, ..., Any], ContextMenu, Group]]:
        ...
    
    def remove_command(self, command: str, /, *, guild: Optional[Snowflake] = ..., type: AppCommandType = ...) -> Optional[Union[Command[Any, ..., Any], ContextMenu, Group]]:
        """Removes an application command from the tree.

        This only removes the command locally -- in order to sync the commands
        and remove them in the client, :meth:`sync` must be called.

        Parameters
        -----------
        command: :class:`str`
            The name of the root command to remove.
        guild: Optional[:class:`~discord.abc.Snowflake`]
            The guild to remove the command from. If not given or ``None`` then it
            removes a global command instead.
        type: :class:`~discord.AppCommandType`
            The type of command to remove. Defaults to :attr:`~discord.AppCommandType.chat_input`,
            i.e. slash commands.

        Returns
        ---------
        Optional[Union[:class:`Command`, :class:`ContextMenu`, :class:`Group`]]
            The application command that got removed.
            If nothing was removed then ``None`` is returned instead.
        """
        ...
    
    def clear_commands(self, *, guild: Optional[Snowflake], type: Optional[AppCommandType] = ...) -> None:
        """Clears all application commands from the tree.

        This only removes the commands locally -- in order to sync the commands
        and remove them in the client, :meth:`sync` must be called.

        Parameters
        -----------
        guild: Optional[:class:`~discord.abc.Snowflake`]
            The guild to remove the commands from. If ``None`` then it
            removes all global commands instead.
        type: :class:`~discord.AppCommandType`
            The type of command to clear. If not given or ``None`` then it removes all commands
            regardless of the type.
        """
        ...
    
    @overload
    def get_command(self, command: str, /, *, guild: Optional[Snowflake] = ..., type: Literal[AppCommandType.message, AppCommandType.user]) -> Optional[ContextMenu]:
        ...
    
    @overload
    def get_command(self, command: str, /, *, guild: Optional[Snowflake] = ..., type: Literal[AppCommandType.chat_input] = ...) -> Optional[Union[Command[Any, ..., Any], Group]]:
        ...
    
    @overload
    def get_command(self, command: str, /, *, guild: Optional[Snowflake] = ..., type: AppCommandType) -> Optional[Union[Command[Any, ..., Any], ContextMenu, Group]]:
        ...
    
    def get_command(self, command: str, /, *, guild: Optional[Snowflake] = ..., type: AppCommandType = ...) -> Optional[Union[Command[Any, ..., Any], ContextMenu, Group]]:
        """Gets an application command from the tree.

        Parameters
        -----------
        command: :class:`str`
            The name of the root command to get.
        guild: Optional[:class:`~discord.abc.Snowflake`]
            The guild to get the command from. If not given or ``None`` then it
            gets a global command instead.
        type: :class:`~discord.AppCommandType`
            The type of command to get. Defaults to :attr:`~discord.AppCommandType.chat_input`,
            i.e. slash commands.

        Returns
        ---------
        Optional[Union[:class:`Command`, :class:`ContextMenu`, :class:`Group`]]
            The application command that was found.
            If nothing was found then ``None`` is returned instead.
        """
        ...
    
    @overload
    def get_commands(self, *, guild: Optional[Snowflake] = ..., type: Literal[AppCommandType.message, AppCommandType.user]) -> List[ContextMenu]:
        ...
    
    @overload
    def get_commands(self, *, guild: Optional[Snowflake] = ..., type: Literal[AppCommandType.chat_input]) -> List[Union[Command[Any, ..., Any], Group]]:
        ...
    
    @overload
    def get_commands(self, *, guild: Optional[Snowflake] = ..., type: AppCommandType) -> Union[List[Union[Command[Any, ..., Any], Group]], List[ContextMenu]]:
        ...
    
    @overload
    def get_commands(self, *, guild: Optional[Snowflake] = ..., type: Optional[AppCommandType] = ...) -> List[Union[Command[Any, ..., Any], Group, ContextMenu]]:
        ...
    
    def get_commands(self, *, guild: Optional[Snowflake] = ..., type: Optional[AppCommandType] = ...) -> Union[List[ContextMenu], List[Union[Command[Any, ..., Any], Group]], List[Union[Command[Any, ..., Any], Group, ContextMenu]],]:
        """Gets all application commands from the tree.

        Parameters
        -----------
        guild: Optional[:class:`~discord.abc.Snowflake`]
            The guild to get the commands from, not including global commands.
            If not given or ``None`` then only global commands are returned.
        type: Optional[:class:`~discord.AppCommandType`]
            The type of commands to get. When not given or ``None``, then all
            command types are returned.

        Returns
        ---------
        List[Union[:class:`ContextMenu`, :class:`Command`, :class:`Group`]]
            The application commands from the tree.
        """
        ...
    
    @overload
    def walk_commands(self, *, guild: Optional[Snowflake] = ..., type: Literal[AppCommandType.message, AppCommandType.user]) -> Generator[ContextMenu, None, None]:
        ...
    
    @overload
    def walk_commands(self, *, guild: Optional[Snowflake] = ..., type: Literal[AppCommandType.chat_input] = ...) -> Generator[Union[Command[Any, ..., Any], Group], None, None]:
        ...
    
    @overload
    def walk_commands(self, *, guild: Optional[Snowflake] = ..., type: AppCommandType) -> Union[Generator[Union[Command[Any, ..., Any], Group], None, None], Generator[ContextMenu, None, None]]:
        ...
    
    def walk_commands(self, *, guild: Optional[Snowflake] = ..., type: AppCommandType = ...) -> Union[Generator[Union[Command[Any, ..., Any], Group], None, None], Generator[ContextMenu, None, None]]:
        """An iterator that recursively walks through all application commands and child commands from the tree.

        Parameters
        -----------
        guild: Optional[:class:`~discord.abc.Snowflake`]
            The guild to iterate the commands from, not including global commands.
            If not given or ``None`` then only global commands are iterated.
        type: :class:`~discord.AppCommandType`
            The type of commands to iterate over. Defaults to :attr:`~discord.AppCommandType.chat_input`,
            i.e. slash commands.

        Yields
        ---------
        Union[:class:`ContextMenu`, :class:`Command`, :class:`Group`]
            The application commands from the tree.
        """
        ...
    
    async def on_error(self, interaction: Interaction[ClientT], error: AppCommandError, /) -> None:
        """|coro|

        A callback that is called when any command raises an :exc:`AppCommandError`.

        The default implementation logs the exception using the library logger
        if the command does not have any error handlers attached to it.

        To get the command that failed, :attr:`discord.Interaction.command` should
        be used.

        Parameters
        -----------
        interaction: :class:`~discord.Interaction`
            The interaction that is being handled.
        error: :exc:`AppCommandError`
            The exception that was raised.
        """
        ...
    
    def error(self, coro: ErrorFunc) -> ErrorFunc:
        """A decorator that registers a coroutine as a local error handler.

        This must match the signature of the :meth:`on_error` callback.

        The error passed will be derived from :exc:`AppCommandError`.

        Parameters
        -----------
        coro: :ref:`coroutine <coroutine>`
            The coroutine to register as the local error handler.

        Raises
        -------
        TypeError
            The coroutine passed is not actually a coroutine or does
            not match the signature.
        """
        ...
    
    def command(self, *, name: Union[str, locale_str] = ..., description: Union[str, locale_str] = ..., nsfw: bool = ..., guild: Optional[Snowflake] = ..., guilds: Sequence[Snowflake] = ..., auto_locale_strings: bool = ..., extras: Dict[Any, Any] = ...) -> Callable[[CommandCallback[Group, P, T]], Command[Group, P, T]]:
        """A decorator that creates an application command from a regular function directly under this tree.

        Parameters
        ------------
        name: Union[:class:`str`, :class:`locale_str`]
            The name of the application command. If not given, it defaults to a lower-case
            version of the callback name.
        description: Union[:class:`str`, :class:`locale_str`]
            The description of the application command. This shows up in the UI to describe
            the application command. If not given, it defaults to the first line of the docstring
            of the callback shortened to 100 characters.
        nsfw: :class:`bool`
            Whether the command is NSFW and should only work in NSFW channels. Defaults to ``False``.

            Due to a Discord limitation, this does not work on subcommands.
        guild: Optional[:class:`~discord.abc.Snowflake`]
            The guild to add the command to. If not given or ``None`` then it
            becomes a global command instead.
        guilds: List[:class:`~discord.abc.Snowflake`]
            The list of guilds to add the command to. This cannot be mixed
            with the ``guild`` parameter. If no guilds are given at all
            then it becomes a global command instead.
        auto_locale_strings: :class:`bool`
            If this is set to ``True``, then all translatable strings will implicitly
            be wrapped into :class:`locale_str` rather than :class:`str`. This could
            avoid some repetition and be more ergonomic for certain defaults such
            as default command names, command descriptions, and parameter names.
            Defaults to ``True``.
        extras: :class:`dict`
            A dictionary that can be used to store extraneous data.
            The library will not touch any values or keys within this dictionary.
        """
        ...
    
    def context_menu(self, *, name: Union[str, locale_str] = ..., nsfw: bool = ..., guild: Optional[Snowflake] = ..., guilds: Sequence[Snowflake] = ..., auto_locale_strings: bool = ..., extras: Dict[Any, Any] = ...) -> Callable[[ContextMenuCallback], ContextMenu]:
        """A decorator that creates an application command context menu from a regular function directly under this tree.

        This function must have a signature of :class:`~discord.Interaction` as its first parameter
        and taking either a :class:`~discord.Member`, :class:`~discord.User`, or :class:`~discord.Message`,
        or a :obj:`typing.Union` of ``Member`` and ``User`` as its second parameter.

        Examples
        ---------

        .. code-block:: python3

            @app_commands.context_menu()
            async def react(interaction: discord.Interaction, message: discord.Message):
                await interaction.response.send_message('Very cool message!', ephemeral=True)

            @app_commands.context_menu()
            async def ban(interaction: discord.Interaction, user: discord.Member):
                await interaction.response.send_message(f'Should I actually ban {user}...', ephemeral=True)

        Parameters
        ------------
        name: Union[:class:`str`, :class:`locale_str`]
            The name of the context menu command. If not given, it defaults to a title-case
            version of the callback name. Note that unlike regular slash commands this can
            have spaces and upper case characters in the name.
        nsfw: :class:`bool`
            Whether the command is NSFW and should only work in NSFW channels. Defaults to ``False``.

            Due to a Discord limitation, this does not work on subcommands.
        guild: Optional[:class:`~discord.abc.Snowflake`]
            The guild to add the command to. If not given or ``None`` then it
            becomes a global command instead.
        guilds: List[:class:`~discord.abc.Snowflake`]
            The list of guilds to add the command to. This cannot be mixed
            with the ``guild`` parameter. If no guilds are given at all
            then it becomes a global command instead.
        auto_locale_strings: :class:`bool`
            If this is set to ``True``, then all translatable strings will implicitly
            be wrapped into :class:`locale_str` rather than :class:`str`. This could
            avoid some repetition and be more ergonomic for certain defaults such
            as default command names, command descriptions, and parameter names.
            Defaults to ``True``.
        extras: :class:`dict`
            A dictionary that can be used to store extraneous data.
            The library will not touch any values or keys within this dictionary.
        """
        ...
    
    @property
    def translator(self) -> Optional[Translator]:
        """Optional[:class:`Translator`]: The translator, if any, responsible for handling translation of commands.

        To change the translator, use :meth:`set_translator`.
        """
        ...
    
    async def set_translator(self, translator: Optional[Translator]) -> None:
        """|coro|

        Sets the translator to use for translating commands.

        If a translator was previously set, it will be unloaded using its
        :meth:`Translator.unload` method.

        When a translator is set, it will be loaded using its :meth:`Translator.load` method.

        Parameters
        ------------
        translator: Optional[:class:`Translator`]
            The translator to use. If ``None`` then the translator is just removed and unloaded.

        Raises
        -------
        TypeError
            The translator was not ``None`` or a :class:`Translator` instance.
        """
        ...
    
    async def sync(self, *, guild: Optional[Snowflake] = ...) -> List[AppCommand]:
        """|coro|

        Syncs the application commands to Discord.

        This also runs the translator to get the translated strings necessary for
        feeding back into Discord.

        This must be called for the application commands to show up.

        Parameters
        -----------
        guild: Optional[:class:`~discord.abc.Snowflake`]
            The guild to sync the commands to. If ``None`` then it
            syncs all global commands instead.

        Raises
        -------
        HTTPException
            Syncing the commands failed.
        CommandSyncFailure
            Syncing the commands failed due to a user related error, typically because
            the command has invalid data. This is equivalent to an HTTP status code of
            400.
        Forbidden
            The client does not have the ``applications.commands`` scope in the guild.
        MissingApplicationID
            The client does not have an application ID.
        TranslationError
            An error occurred while translating the commands.

        Returns
        --------
        List[:class:`AppCommand`]
            The application's commands that got synced.
        """
        ...
    
    async def interaction_check(self, interaction: Interaction[ClientT], /) -> bool:
        """|coro|

        A global check to determine if an :class:`~discord.Interaction` should
        be processed by the tree.

        The default implementation returns True (all interactions are processed),
        but can be overridden if custom behaviour is desired.
        """
        ...
    


