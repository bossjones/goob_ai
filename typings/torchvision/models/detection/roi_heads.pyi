"""
This type stub file was generated by pyright.
"""

import torch
from typing import Dict, List, Optional, Tuple
from torch import Tensor, nn

def fastrcnn_loss(class_logits: Tensor, box_regression: Tensor, labels: List[Tensor], regression_targets: List[Tensor]) -> Tuple[Tensor, Tensor]:
    """
    Computes the loss for Faster R-CNN.

    Args:
        class_logits (Tensor)
        box_regression (Tensor)
        labels (list[BoxList])
        regression_targets (Tensor)

    Returns:
        classification_loss (Tensor)
        box_loss (Tensor)
    """
    ...

def maskrcnn_inference(x: Tensor, labels: List[Tensor]) -> List[Tensor]:
    """
    From the results of the CNN, post process the masks
    by taking the mask corresponding to the class with max
    probability (which are of fixed size and directly output
    by the CNN) and return the masks in the mask field of the BoxList.

    Args:
        x (Tensor): the mask logits
        labels (list[BoxList]): bounding boxes that are used as
            reference, one for ech image

    Returns:
        results (list[BoxList]): one BoxList for each image, containing
            the extra field mask
    """
    ...

def project_masks_on_boxes(gt_masks: Tensor, boxes: Tensor, matched_idxs: Tensor, M: int) -> Tensor:
    """
    Given segmentation masks and the bounding boxes corresponding
    to the location of the masks in the image, this function
    crops and resizes the masks in the position defined by the
    boxes. This prepares the masks for them to be fed to the
    loss computation as the targets.
    """
    ...

def maskrcnn_loss(mask_logits: Tensor, proposals: List[Tensor], gt_masks: List[Tensor], gt_labels: List[Tensor], mask_matched_idxs: List[Tensor]) -> Tensor:
    """
    Args:
        proposals (list[BoxList])
        mask_logits (Tensor)
        targets (list[BoxList])

    Return:
        mask_loss (Tensor): scalar tensor containing the loss
    """
    ...

def keypoints_to_heatmap(keypoints: Tensor, rois: Tensor, heatmap_size: int) -> Tuple[Tensor, Tensor]:
    ...

def heatmaps_to_keypoints(maps, rois): # -> tuple[Tensor, Tensor]:
    """Extract predicted keypoint locations from heatmaps. Output has shape
    (#rois, 4, #keypoints) with the 4 rows corresponding to (x, y, logit, prob)
    for each keypoint.
    """
    ...

def keypointrcnn_loss(keypoint_logits: Tensor, proposals: List[Tensor], gt_keypoints: List[Tensor], keypoint_matched_idxs: List[Tensor]) -> Tensor:
    ...

def keypointrcnn_inference(x: Tensor, boxes: List[Tensor]) -> Tuple[List[Tensor], List[Tensor]]:
    ...

def expand_boxes(boxes: Tensor, scale: float) -> Tensor:
    ...

@torch.jit.unused
def expand_masks_tracing_scale(M: int, padding: int) -> float:
    ...

def expand_masks(mask: Tensor, padding: int) -> Tuple[Tensor, float]:
    ...

def paste_mask_in_image(mask: Tensor, box: Tensor, im_h: int, im_w: int) -> Tensor:
    ...

def paste_masks_in_image(masks: Tensor, boxes: Tensor, img_shape: Tuple[int, int], padding: int = ...) -> Tensor:
    ...

class RoIHeads(nn.Module):
    __annotations__ = ...
    def __init__(self, box_roi_pool, box_head, box_predictor, fg_iou_thresh, bg_iou_thresh, batch_size_per_image, positive_fraction, bbox_reg_weights, score_thresh, nms_thresh, detections_per_img, mask_roi_pool=..., mask_head=..., mask_predictor=..., keypoint_roi_pool=..., keypoint_head=..., keypoint_predictor=...) -> None:
        ...
    
    def has_mask(self): # -> bool:
        ...
    
    def has_keypoint(self): # -> bool:
        ...
    
    def assign_targets_to_proposals(self, proposals: List[Tensor], gt_boxes: List[Tensor], gt_labels: List[Tensor]) -> Tuple[List[Tensor], List[Tensor]]:
        ...
    
    def subsample(self, labels: List[Tensor]) -> List[Tensor]:
        ...
    
    def add_gt_proposals(self, proposals: List[Tensor], gt_boxes: List[Tensor]) -> List[Tensor]:
        ...
    
    def check_targets(self, targets: Optional[List[Dict[str, Tensor]]]) -> None:
        ...
    
    def select_training_samples(self, proposals: List[Tensor], targets: Optional[List[Dict[str, Tensor]]]) -> Tuple[List[Tensor], List[Tensor], List[Tensor], List[Tensor]]:
        ...
    
    def postprocess_detections(self, class_logits: Tensor, box_regression: Tensor, proposals: List[Tensor], image_shapes: List[Tuple[int, int]]) -> Tuple[List[Tensor], List[Tensor], List[Tensor]]:
        ...
    
    def forward(self, features: Dict[str, Tensor], proposals: List[Tensor], image_shapes: List[Tuple[int, int]], targets: Optional[List[Dict[str, Tensor]]] = ...) -> Tuple[List[Dict[str, Tensor]], Dict[str, Tensor]]:
        """
        Args:
            features (List[Tensor])
            proposals (List[Tensor[N, 4]])
            image_shapes (List[Tuple[H, W]])
            targets (List[Dict])
        """
        ...
    


